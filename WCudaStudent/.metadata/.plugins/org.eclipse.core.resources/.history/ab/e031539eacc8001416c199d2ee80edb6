#ifndef NEWTON_MATH_H_
#define NEWTON_MATH_H_

#include <math.h>
#include "ColorTools_GPU.h"
#include "CalibreurF.h"
#include "ColorTools.h"

/*----------------------------------------------------------------------*\
 |*			Declaration 					*|
 \*---------------------------------------------------------------------*/

/*--------------------------------------*\
 |*		Public			*|
 \*-------------------------------------*/

class NewtonMath
    {

	/*--------------------------------------*\
	|*		Constructor		*|
	 \*-------------------------------------*/

    public:

	__device__ NewtonMath(int n):calibreur(IntervalF(0, n), IntervalF(0, 1))
		    {
		    this->n = n;
		    }

	/*--------------------------------------*\
	|*		Methodes		*|
	 \*-------------------------------------*/

    public:
	__device__ void colorXY(uchar4* ptrColor, float x, float y, const DomaineMath& domaineMath)
		    {

		    bool converge = false;

		    int index = 0;
		    while(index++ <= n && !converge)
			{
			float x1Copy = x1;
			float x2Copy = x2;

			x1 = x1Next(x1, x2);
			x2 = x2Next(x1Copy, x2);

			computeIndiceArret(x1Copy, x2Copy, x1, x2, converge);
			}

		    color.x = color.y = color.z = 30;
		    if(converge)
			{
			double distA = distance2(x1, xa1()) + distance2(x2, xa2());
			double distB = distance2(x1, xb1()) + distance2(x2, xb2());
			double distC = distance2(x1, xc1()) + distance2(x2, xc2());

			if(distA < distB && distA < distC)
			    color.x = color.y = color.z = 0;
			else if(distB < distC)
			    color.x = color.y = color.z = 128;
			else
			    color.x = color.y = color.z = 255;
			}

		    /*int k = computeIndiceArret(x, y);

		    if(k <= this->n)
		       {
			float hue01 = (float) k;
			calibreur.calibrer(hue01);

			ColorTools::HSB_TO_RVB(hue01, ptrColor); // update color
		       }
		    else
		       {
		       ptrColor->x = 0;
		       ptrColor->y = 0;
		       ptrColor->z = 0;
		       }*/

		    ptrColor->w = 255; // opaque
		    }


	__device__  int computeIndiceArret(double x1, double x2, double x1Next, double x2Next, bool converge)
	    {
	    converge = (distance(x1, x1Next) + distance(x2, x2Next))/(x1Next*x1Next+x2Next*x2Next) < epsilon;
	    }
	__device__ float distance(const float x1, const float x2) const {return (x2-x1)*(x2-x1);}

	__device__ float x1Next(const float x1, const float x2) const {return (1/(float)3)*(x1-((2*x1*x1)/((x1*x1+x2*x2)*(x1*x1+x2*x2)) + ((1)/(x1*x1+x2*x2)) ));}
	__device__ float x2Next(const float x1, const float x2) const {return ((1/ (float)3)) *x2* ( (1)+ ( (2*x1)/( (x1*x1+x2*x2)*(x1*x1+x2*x2) ) ) );}

    private:

	/*--------------------------------------*\
	|*		Attributs		*|
	 \*-------------------------------------*/

    private:


	// Inputs
	int n;
	// Tools
	CalibreurF calibreur;

    };

#endif 

/*----------------------------------------------------------------------*\
 |*			End	 					*|
 \*---------------------------------------------------------------------*/
